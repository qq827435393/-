3. 装载时重定位

任何文件要被装载进虚拟进程空间，是需要有个装载地址的，显然主程序文件被装载进虚拟进程空间时是没有人和它争的，而其他动态链接库装载时，则可能出现装载地址冲突的问题。
显然为每个贡献库模块指定固定载入地址，是会严重限制程序升级，甚至导致模块间出现地址冲突。这种做法被称作静态共享库（不是静态库），它的做法是将多种模块统一交给OS，让OS在特定的地址范围内划分出足够的空间预留给这些已知模块。因为静态共享库存在足够先天设计的弊病，导致这种设计很少见，已经被动态链接彻底取代。(装载时动态库的位置不确定!!!!)

换个说法：.so对象在编译时不能假设自己在进程虚拟空间中的位置，但是可执行文件可以唯一确定自己的起始位置，因为可执行文件往往是第一个被加载的文件，它可以选择一个固定空闲的地址，如Linux下一般是0x08040000，Windows下一般是0x00400000。
------------------------
所以对于共享对象文件而言是存在一个所谓“装载时所有地址引用重定位”的需求。那么该如何实现这种重定位目的呢？
------------------------

装载时重定位便是针对这个目的的一个直接方法：根据共享对象在装载时的真正位置，遍历共享对象文件中所有的绝对地址引用，不过由于整个共享对象是作为一个整体被加载的，故而程序中指令和数据的相对位置是不会变的，如果一个共享对象文件被编译时先预设自己的装载位置为0x1000，但在装载时被分配到0x4000，则共享对象程序文件中所有绝对地址引用只需要加上0x3000的整体偏移量即可。

装载时重定位可以解决动态模块中有绝对地址引用的情况，但是它最大的缺点是在内存中的指令部分将因为绝对地址修改导致在多个进程间无法共享，并不节省内存，只节省了磁盘空间，并不节省内存空间。

:::::(运行时)装载重定位..自己理解
程序刚开始运行时,只是生成了一个虚拟内存到共享对象(硬盘文件)的关系,没有重定位,等到--->
执行程序用到so对象中的函数或者变量时,缺页,将共享库代码数据装载进内存,重定位共享对象文件的所有绝对地址引用.页表修改,重新执行缺页处代码..此时装入内存的共享库代码时经过重定向修改的,其它进程不能共享,只能在自己装载时.重新生成一份新的内存拷贝共享内存.


其它资料:::
共享对象在被装载时，是如何确定它在进程虚拟地址空间中的位置？
一种方法是固定装载，这种方法弊端明显：地址冲突；共享库升级困难；空间受限等等。（基本不用）

